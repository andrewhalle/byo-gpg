[2020-08-30T14:42:47-0700]

goals:
  * generate key
  * import keys
  * generate encrypted message
  * decrypt message
  * sign message
  * verify signed message
  * completely compatible with gpg

start with RSA, consider other algorithms later. first thing to do,
generate large primes. use `num` crate to get bigint functionaltiy
(BigUint). it also has a random sampler, so that's easy. Use primality
testing (first basic testing against the first few primes, then fermat,
then miller/rabin) to determine whether the randomly generated number
is prime. Finally, parallelize prime generation with rayon (this was
particularly satisfying, the code changes were minimal, just switching
to use the `parallel` iterator, and the `find_any` combinator. the speedup
was immense, down from about 10 seconds to under 1 second for 1024 bit primes,
and down from 1-5 minutes to about 10 seconds for 2048 bit primes.)

for next time: nice loading bars for the terminal to show activity while
the primes are being generated, and actually generating the key from
the primes.

[2020-09-02T20:40:50-0700]

nice loading bars, let's use termprogress.

started by writing a quick test for the `is_probable_prime` function,
ended up finding a bug in my implementation because of my implementation
of gen_range, (generating numbers of BIT_SIZE and while looping if bigger)
found the RandBigInt trait which could do what I needed.

right now, just going to hard code an estimation time, figure out how
to actually estimate this later.

[next time] generate key, try to actually encrypt something

[2020-09-04T19:41:54-0700]

generated a key using the RSA procedure, thought I would have to write
gcd and extended_gcd, but they're provided by the num crate (in the Integer
trait). I suspect I'm still missing some nice functions that might make
my life easier.

then, wrote out the keys to a file using serde. for now, just json. eventually,
will actually produce keys in the pgp format.

[next time]
  * encrypt something
  * decrypt something

[2020-09-05T12:06:57-0700]

going to try to encrypt an integer, not worry about padding schemes yet.

since a biguint can be constructed from a byte slice, I've just taken the
string as a utf8 byte slice and used that for the message. Will want to 
change this at some point.

successfully encrypted / decrypted a message. All the file paths are hardcoded
for right now, and decrypting the message just prints it out.

[next time] command line options for specifying where the files come from

[2020-09-07T18:09:01-0700]

starting with improving the command line functionality.

clap makes it easy to add command line arguments, for now, I'll always accept
filenames, and consider defaulting to stdin / stdout later, after some re-arranging
to make that easier.

wasn't happy with my struct definitons for the keys, because I was converting BigUint
to Vec<u8> to use serde. Turns out there's a feature in num for turning on serde support,
so was able to change these definitions.

[next time] refactor, modularize, and tests

[2020-09-09T20:08:35-0700]

alright, time to refactor, modularize, and test. split large functions. particularly proud
of do_task_with_progress, which uses fancy generics to take a closure, and return whatever
the closure returns.

successfully modularized, just considered function length / general areas of interest.

[next time] testing

[begin 2020-09-12T10:58:22-0700]

alright, let's write some tests. had to do a bit of refactoring to remove randomness from
some functions with logic.

the rsa module proved harder to test. the only function that didn't have some randomness or
output was the carmichaels_totient_function. note to self to refactor rsa to better separate
concerns.

[end 2020-09-12T11:36:53-0700]
[next time] parse a clearsigned PGP signature into a data structure.

[begin 2020-09-12T17:17:50-0700]

alright, let's start parsing. link for the RFC https://tools.ietf.org/html/rfc4880 (section 7)
and I'll be using nom https://github.com/Geal/nom.

start by defining the data structure I want back.

got some experience writing nom parsers. seems powerful, not sure I have
the best handle on it yet. My code is pretty gross right now. Current parser
is very based on the example file that I have. make this more general by better
understanding the RFC. what are the small number of characters after the base64
blob for? need to also parse the base64 data into actual bytes, and turn that into
a signature defined in the RFC.

[end 2020-09-12T18:53:24-0700]
[next time] recognize dash escaping in the PGP signature parser. clean up this code. 

[begin 2020-09-13T20:21:45-0700]

recognizing dash escaping. i think that replacing '\n- ' with '\n' should be enough.
also had to strip '- ' from the beginning. the rust api for stripping a prefix from a
string slice is a little wonky, returning Option<&str> if it successfully stripped,
else returning None.

[end 2020-09-13T21:08:15-0700]
[next time] make PgpSignature struct, turn base64 into bytes and parse it

[begin 2020-09-16T19:00:37-0700]
okay, did a little reading, found out what the small number of characters after
the base64 blob are, they're a CRC-24 checksum of the preceding blob. See the RFC
for implementation details (ch 6)

this was a very straightforward implementation. the c implementation translated nicely
to rust, and it worked immediately. i was also able to re-write the base64 parser to be
more correct / account for there being no '=' at the end of the data, using fold_many0.
parser combinators are super cool. still have a bug in my implementation that I just
realized (when data is exactly as long as a line, won't recognize the end) but I'll fix
that later.

[end 2020-09-16T19:56:39-0700]
[next time] fix the bug in parse_base64, implement a command `verify` instead of my current
            test command, and start defining the structure of a PgpSignature.

[begin 2020-09-20T17:58:26-0700]

first, fixing the bug in parse_base64. wrote a real is_base_64_char function.

[2020-09-20T18:14:53-0700] break for dinner
[2020-09-20T21:08:45-0700] back

should an invalid checksum be a parse error? on the one hand no, because computation is
not part of the grammar. On the other hand, when parsing is the most convenient place to
compute the checksum, since that's where we have access to the raw bytes of the signature
we're about to parse. must think more on this.

looks like I'll have to start dealing with packets now. i thought I would be able to just
use new style packets, but judging from my test signature, I actually will be dealing with
old style packets

pgpdump is going to be invaluable.

successfully parsing the packet header (in my example file, old version, packet tag 2, length
307)

[2020-09-20T22:19:08-0700] end
[next time] continue with parsing the PgpPacket
