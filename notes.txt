[2020-08-30T14:42:47-0700]

goals:
  * generate key
  * import keys
  * generate encrypted message
  * decrypt message
  * sign message
  * verify signed message
  * completely compatible with gpg

start with RSA, consider other algorithms later. first thing to do,
generate large primes. use `num` crate to get bigint functionaltiy
(BigUint). it also has a random sampler, so that's easy. Use primality
testing (first basic testing against the first few primes, then fermat,
then miller/rabin) to determine whether the randomly generated number
is prime. Finally, parallelize prime generation with rayon (this was
particularly satisfying, the code changes were minimal, just switching
to use the `parallel` iterator, and the `find_any` combinator. the speedup
was immense, down from about 10 seconds to under 1 second for 1024 bit primes,
and down from 1-5 minutes to about 10 seconds for 2048 bit primes.)

for next time: nice loading bars for the terminal to show activity while
the primes are being generated, and actually generating the key from
the primes.

[2020-09-02T20:40:50-0700]

nice loading bars, let's use termprogress.

started by writing a quick test for the `is_probable_prime` function,
ended up finding a bug in my implementation because of my implementation
of gen_range, (generating numbers of BIT_SIZE and while looping if bigger)
found the RandBigInt trait which could do what I needed.

right now, just going to hard code an estimation time, figure out how
to actually estimate this later.

[next time] generate key, try to actually encrypt something

[2020-09-04T19:41:54-0700]

generated a key using the RSA procedure, thought I would have to write
gcd and extended_gcd, but they're provided by the num crate (in the Integer
trait). I suspect I'm still missing some nice functions that might make
my life easier.

then, wrote out the keys to a file using serde. for now, just json. eventually,
will actually produce keys in the pgp format.

[next time]
  * encrypt something
  * decrypt something

[2020-09-05T12:06:57-0700]

going to try to encrypt an integer, not worry about padding schemes yet.

since a biguint can be constructed from a byte slice, I've just taken the
string as a utf8 byte slice and used that for the message. Will want to 
change this at some point.

successfully encrypted / decrypted a message. All the file paths are hardcoded
for right now, and decrypting the message just prints it out.

[next time] command line options for specifying where the files come from

[2020-09-07T18:09:01-0700]

starting with improving the command line functionality.

clap makes it easy to add command line arguments, for now, I'll always accept
filenames, and consider defaulting to stdin / stdout later, after some re-arranging
to make that easier.

wasn't happy with my struct definitons for the keys, because I was converting BigUint
to Vec<u8> to use serde. Turns out there's a feature in num for turning on serde support,
so was able to change these definitions.

[next time] refactor, modularize, and tests

[2020-09-09T20:08:35-0700]

alright, time to refactor, modularize, and test. split large functions. particularly proud
of do_task_with_progress, which uses fancy generics to take a closure, and return whatever
the closure returns.

successfully modularized, just considered function length / general areas of interest.

[next time] testing

[begin 2020-09-12T10:58:22-0700]

alright, let's write some tests. had to do a bit of refactoring to remove randomness from
some functions with logic.

the rsa module proved harder to test. the only function that didn't have some randomness or
output was the carmichaels_totient_function. note to self to refactor rsa to better separate
concerns.

[end 2020-09-12T11:36:53-0700]
[next time] parse a clearsigned PGP signature into a data structure.

[begin 2020-09-12T17:17:50-0700]

alright, let's start parsing. link for the RFC https://tools.ietf.org/html/rfc4880 (section 7)
and I'll be using nom https://github.com/Geal/nom.

start by defining the data structure I want back.

got some experience writing nom parsers. seems powerful, not sure I have
the best handle on it yet. My code is pretty gross right now. Current parser
is very based on the example file that I have. make this more general by better
understanding the RFC. what are the small number of characters after the base64
blob for? need to also parse the base64 data into actual bytes, and turn that into
a signature defined in the RFC.

[end 2020-09-12T18:53:24-0700]
[next time] recognize dash escaping in the PGP signature parser. clean up this code. 

[begin 2020-09-13T20:21:45-0700]

recognizing dash escaping. i think that replacing '\n- ' with '\n' should be enough.
also had to strip '- ' from the beginning. the rust api for stripping a prefix from a
string slice is a little wonky, returning Option<&str> if it successfully stripped,
else returning None.

[end 2020-09-13T21:08:15-0700]
[next time] make PgpSignature struct, turn base64 into bytes and parse it

[begin 2020-09-16T19:00:37-0700]
okay, did a little reading, found out what the small number of characters after
the base64 blob are, they're a CRC-24 checksum of the preceding blob. See the RFC
for implementation details (ch 6)

this was a very straightforward implementation. the c implementation translated nicely
to rust, and it worked immediately. i was also able to re-write the base64 parser to be
more correct / account for there being no '=' at the end of the data, using fold_many0.
parser combinators are super cool. still have a bug in my implementation that I just
realized (when data is exactly as long as a line, won't recognize the end) but I'll fix
that later.

[end 2020-09-16T19:56:39-0700]
[next time] fix the bug in parse_base64, implement a command `verify` instead of my current
            test command, and start defining the structure of a PgpSignature.

[begin 2020-09-20T17:58:26-0700]

first, fixing the bug in parse_base64. wrote a real is_base_64_char function.

[2020-09-20T18:14:53-0700] break for dinner
[2020-09-20T21:08:45-0700] back

should an invalid checksum be a parse error? on the one hand no, because computation is
not part of the grammar. On the other hand, when parsing is the most convenient place to
compute the checksum, since that's where we have access to the raw bytes of the signature
we're about to parse. must think more on this.

looks like I'll have to start dealing with packets now. i thought I would be able to just
use new style packets, but judging from my test signature, I actually will be dealing with
old style packets

pgpdump is going to be invaluable.

successfully parsing the packet header (in my example file, old version, packet tag 2, length
307)

[2020-09-20T22:19:08-0700] end
[next time] continue with parsing the PgpPacket

[2020-09-22T20:01:26-0700] begin

alright, continuing to parse PgpPacket...

I think I've run into my first problem where gpg implements something not covered
by the rfc. a signature packet contains signature subpackets, which have a type field.
one of the packets in my test signature has type 33, which is in the private/reserved
range of the rfc. some googling led me to this issue https://github.com/keybase/keybase-issues/issues/2668
which shows that this is an experimental gpg addition. pgpdump recognizes this packet,
but i think i can freely choose to ignore it, since it's not actually specified in the
rfc.

I can however recognize the date field (i tried it manually and was able to pull out
the same date that pgpdump recognized. more on this later.)

[2020-09-22T20:44:32-0700] end
[next time] refactor PgpPacket type to allow for future subpacket types, clean up PgpPacket::parse
            which has gotten very ugly.

[2020-09-26T11:34:34-0700] begin

pgppacket needs to be an enum with the different types, and there should also be a pgpsubpacket type.
pgppacket ought to have a vec of pgpsubpackets

started re-arranging and had to comment out quite a bit of stuff to achieve a build. started with
writing a parser for mpis (as defined in section 3.2 of the rfc). started parsers module, will move
parsers previously written in the pgp module into this new module for cleanliness. will add tests at
the same time.

[2020-09-26T12:39:30-0700] end
[next time] continue moving parsers over into parsers.rs, probably make pgp.rs a directory with signature.rs,
            encryption.rs, etc

[2020-09-27T16:07:52-0700] begin

starting with making AsciiArmoredMessage type which will be the thing to verify the checksum, and allow
parsing the resulting bytes into a specific PGP type.

[2020-09-27T16:36:06-0700] end
[next time] wire up AsciiArmoredMessage to the specific signature type (e.g. AsciiArmoredMessage should
            if its type is SIGNATURE, expect one signature packet)

[2020-09-28T17:35:03-0700] begin

I've drawn out the flow of parsing cleartext signatures in my notebook, getting a CleartextSignature from
a string will happen in several stages. first, the hash, message, and ascii armor will be parsed. if that
succeeds, then the ascii armor checksum will be checked. if that succeeds, then the ascii armor will be parsed
into a specific struct (in this case, PgpSignature).

since there are 3 phases could fail in different ways, I'll use anyhow to unite the error handling (indeed,
make use of anyhow throughout this application) and make parse methods that return tuples of pieces that
will be needed in later stages, rather than make a specific struct to hold them. Today, write just the new
parser for dash-escaped text, and include anyhow.

[2020-09-28T18:20:04-0700] took break for dinner
[2020-09-28T18:44:07-0700] back

I got to use unsafe! I needed to extend a string slice by one byte, which I know is safe to do once I've checked
the next character is a newline, but there's no way to safely do so. Enter unsafe!

the resulting code is incredibly clean for parsing the chunk of cleartext that's part of the signature. now I'm
wondering if it would be possible to do just one string allocation by doing unsafe pointer stuff, returning a list
of &str and doing unsafe to concat them all to a string, but I'm very satisfied with this.

now to include anyhow. won't actually do anything with it tonight.
