[2020-08-30T14:42:47-0700]

goals:
  * generate key
  * import keys
  * generate encrypted message
  * decrypt message
  * sign message
  * verify signed message
  * completely compatible with gpg

start with RSA, consider other algorithms later. first thing to do,
generate large primes. use `num` crate to get bigint functionaltiy
(BigUint). it also has a random sampler, so that's easy. Use primality
testing (first basic testing against the first few primes, then fermat,
then miller/rabin) to determine whether the randomly generated number
is prime. Finally, parallelize prime generation with rayon (this was
particularly satisfying, the code changes were minimal, just switching
to use the `parallel` iterator, and the `find_any` combinator. the speedup
was immense, down from about 10 seconds to under 1 second for 1024 bit primes,
and down from 1-5 minutes to about 10 seconds for 2048 bit primes.)

for next time: nice loading bars for the terminal to show activity while
the primes are being generated, and actually generating the key from
the primes.

[2020-09-02T20:40:50-0700]

nice loading bars, let's use termprogress.

started by writing a quick test for the `is_probable_prime` function,
ended up finding a bug in my implementation because of my implementation
of gen_range, (generating numbers of BIT_SIZE and while looping if bigger)
found the RandBigInt trait which could do what I needed.

right now, just going to hard code an estimation time, figure out how
to actually estimate this later.

[next time] generate key, try to actually encrypt something

[2020-09-04T19:41:54-0700]

generated a key using the RSA procedure, thought I would have to write
gcd and extended_gcd, but they're provided by the num crate (in the Integer
trait). I suspect I'm still missing some nice functions that might make
my life easier.

then, wrote out the keys to a file using serde. for now, just json. eventually,
will actually produce keys in the pgp format.

[next time]
  * encrypt something
  * decrypt something

[2020-09-05T12:06:57-0700]

going to try to encrypt an integer, not worry about padding schemes yet.

since a biguint can be constructed from a byte slice, I've just taken the
string as a utf8 byte slice and used that for the message. Will want to 
change this at some point.

successfully encrypted / decrypted a message. All the file paths are hardcoded
for right now, and decrypting the message just prints it out.

[next time] command line options for specifying where the files come from

[2020-09-07T18:09:01-0700]

starting with improving the command line functionality.

clap makes it easy to add command line arguments, for now, I'll always accept
filenames, and consider defaulting to stdin / stdout later, after some re-arranging
to make that easier.

wasn't happy with my struct definitons for the keys, because I was converting BigUint
to Vec<u8> to use serde. Turns out there's a feature in num for turning on serde support,
so was able to change these definitions.

[next time] refactor, modularize, and tests
